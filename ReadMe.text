스프링 기본편

프레임워크 : 프레임워크가 내가작성한 코드를 제어하고 대신실행하면 그것은 프레임워크가 맞다 (JUnit)
라이브러리 : 내가작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 라이브러리다 (내가직접호출하거나 실행)


IoC, DI
- 제어의역전(IoC Inversion of Control)
    - 기존프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현객체를 생성하고 연결하고 실행했다 한마디로 구현객체가 프로그램의 제어 흐름을 스스로 조종했다 개발자 입장에서는 자연스러운흐름이다.
    - 반면에 AppConfig가 등장한 이후 구현객체는 자신의 로직을 시행하는 역할만 담당한다 프로그램의 제어흐름은 이제 AppConfig 가 가져간다 예를들어 'OrderServiceImpl' 은 필요한 인터페이스를 호출하지만
      어떤 구현객체들이 실행될지모른다
    - 프로그램에 대한 제어흐름의 권한은 모두 AppConfig 가 가지고있다 심지어 'OrderServiceImpl' 도 AppConfig 가 생성한다 그리고 AppConfig는 'OrderServiceImpl' 아닌 OrderService 의 인터페이스의
      다른 구현객체를 생성하고 실행할수도있다
    - 이렇듯 프로그램의 제어흐름을 직접 제어하는것이 아니라 외부에서 관리하는것을 제어의역전(IoC) 라고한다

- 의존관계주입(DI Dependency Injection)
    - 'OrderServiceImpl' 은 'DiscountPolicy' 인터페이스에 의존한다. 실제어떤 구현객체가 사용될지모른다.
    - 의존관계는 '정적인 클래스 의존관계와, 실행시점에 결정되는 동적인 객체(인스턴스) 의존관계' 둘을 분리해서 생각해야한다.
        -- 정적인 클래스 의존관계는 import 코드만보고도 알수있다

        -- 동적인 의존관계는 애플리케이션 실행시점에 실제 생성된 객체 인스턴스의 참조가 연결된것

IoC 컨테이너 DI 컨테이너

    - AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는것을 IoC 컨테이너 또는 DI 컨테이너라고한다
    - 의존관계 주입에 초점을 맞추어 최근에는 주로 DI컨테이너라고한다
    - 또는 어셈블러, 오브젝트 팩토리 등으로 불리기도한다.


BeanFactory
    - 스프링 컨테이너에 최상위 인터페이스다.
    - 스프링 빈을 관리하고 조회하는 역할을 담당한다.
    - getBean() 을 제공한다.
    - 지금까지 우리가 사용했던 대부분의 기능은 BeanFactory 가 제공하는 기능이다.

ApplicationContext
    - BeanFactory 기능을 모두 상속받아서 제공한다.
    - 빈을 관리하고 검색하는 기능을 BeanFactory 가 제공해주는데 그러면 둘의차이는뭘까?
    - 애플리케이션을 개발할때 빈은관리하고 조회하는 기능은 물론이고 수많은 부가기능이 필요하다.

    -EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,
     MessageSource, ApplicationEventPublisher, ResourcePatternResolver

    - 메시지소스를 활용한 국제화 기능
        - 한곡에서는 한국어, 영어권에서는 영어로 출력
    - 환경변수
        - 로컬, 개발, 운영등을 구분해서 처리
    - 애플리케이션 이벤트
        - 이벤트를 발행하고 구독하는 모델을 편리하게 지원
    - 편리한 리소스 조회
        - 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회

    - 정리
        -- ApplicationContext 는 BeanFactory 의 기능을 상속받는다
        -- ApplicationContext 는 빈관리기능 + 편리한 부가기능을 제공한다.
        -- BeanFactory 를 직접사용할일은 거의없다 부가기능이 포함된 ApplicationContext 을 사용한다.
        -- BeanFactory 나 ApplicationContext 를 스프링 컨테이너라고 한다.

스프링 빈 설정 메타정보 - BeanDefinition
    - 스프링은 어떻게 이렇게 다양한 설정 형식을 지원하는 것일까? 그 중심에는 BeanDefinition 이라는 추상화가 있다.
    - 쉽게 이야기해서 역할과 구현을 개념적으로 나눈것 이다.
        - XML 을 읽어서 BeanDefinition 을 만들면 된다.
        - 자바 코드를 읽어서 BeanDefinition 을 만들면 된다.
        - 스프링 컨테이너는 자바 코드인지 XML 인지 몰라도 오직 BeanDefinition 만알면된다.
    - BeanDefinition 을 빈 설정 메타정보라고한다.
        - @Bean , <bean> 당 각각 하나씩 메타정보가 생선된다.
    - 스프링 컨테이너는 메타정보를 기반으로 스프링 빈을 설정한다.

    - AnnotationConfigApplicationContext 는 AnnotatedBeanDefinitionReader 를 사용해서
      AppConfig.class 를 읽고 BeanDefinition 을 생성한다.

    - GenericXmlApplicationContext 는 XmlBeanDefinitionReader 를 사용해서
      appConfig.xml 설정정보를 읽고 BeanDefinition 을 생성한다.

    - 새로운 형식의 설정정보가 추가되면 XxxBeanDefinitionReader 를 만들어서 BeanDefinition 을 생성하면된다.

 /**    BeanDefinitionTest << 에 정리또해놈   */


싱글톤 패턴
    - 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인패턴.
    - 그래서 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야한다.
        -- private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막아야한다.


## 싱글톤 패턴을 적용하면 고객의 요청이 올때마다 객체를 생성하는것이 아니라, 이미 만들어진 객체를 공유해서 효율적으로 사용 할수있다.
   하지만 싱글톤 패턴은 다음과 같은 수많은 문제점들을 가지고있다.

   - 싱글톤 패턴 문제점
    -- 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
    -- 의존관계상 클라이언트가 구체 클래스에 의존한다. -> DIP를 위반한다
    -- 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다
    -- 테스트 하기가 어렵다
    -- 내부속성을 변경하거나 초기화 하기 어렵다.
    -- private 생성자로 자식 클래스를 만들기 어렵다.
    -- 결론적으로 유연성이 떨어진다
    -- 안티패턴으로 불리기도한다.

## 싱글톤 컨테이너
    - 스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤(1개만 생성) 으로 관리한다.
      지금까지 우리가 학습한 스프링 빈이 바로 싱글톤으로 관리되는 빈이다.
    - 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.
    - 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다, 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 한다.
    - 스프링 컨테이너의 이런 기능 덕분에 싱글톤 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할수있다.
        -- 싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 된다.
        -- DIP, OCP, 테스트, private 생성자로 부터 자유롭게 싱글톤을 사용할수있다.

## 싱글톤 방식의 주의점
    - 싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은
      여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 떄문에 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.
    - 무상태(stateless) 로 설계 해야한다.
        -- 특정 클라이언트에 의존적인 필드가 있으면안된다.
        -- 특정 클라이언트가 값을 변경 할 수 있는 필드가 있으면안된다.
        -- 가급적 읽기만 가능해야한다.
        -- 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야한다.
    - 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수있다.


## 다양한 의존관계주입방법
    - 생성자 주입
        -- 생성자 호출시점에 딱 1번만 호출되는것이 보장된다
        -- 불변, 필수 의존관계에 사용
    - 수정자 주입(setter 주입)
    - 필드 주입
        -- 코드가 간결해서 많은 개발자들을 유혹하지만 외부에서 변경이 불가능해서 테스트 하기 힘들다는 치명적인 단점이 있다.
        -- DI 프레임워크가 없으면 아무것도 할수없다.
        -- 사용하지말자
            -- 애플리케이션의 실제 코드와 관계없는 테스트 코드
            -- 스프링 설정을 목적으로하는 @Configuration 같은 곳에서만 특별한 용도로 사용
    - 일반 메서드 주입

## 생성자주입을 선택해라 ##

    # 불변
        - 대부분 의존관계 주입은 한번일어나면 애플리케이션 종료시점까지 의존관계를 변경할일이없다. 오히려 대부분 의존관계는 애플리케이션 종료 전까지 변하면안된다.
        - 수정자 주입을 사용하면 setXXX 메서드를 public 으로 열어두어야한다.
        - 누군가 실수로 변경할수도있고 변경하면 안되는 메서드를 열어두는것도 좋은 설계는아니다.
        - 생성자 주입은 객체를 생성할때 딱 1 번만 호출되므로 이후에 호출되는일이없다 따라서 불변하게 설계할수있다.
    # 누락

## 조회대상 빈이 2개 이상일경우 해결방법
    - @Autowired 필드명 매칭
        -- @Autowired 는 타입매칭을 시도하고 이떄 여러빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭한다.
        -- (ex)
            (기존코드)                                  (필드명을 빈이름으로 지정)
            private DiscountPolicy discountPolicy -> private DiscountPolicy rateDiscountPolicy
    - @Qualifier -> @Qualifier 끼리 매칭 -> 빈이름 매칭
        -- @Qualifier 는 추가 구분자를 붙여주는 방법이다. 주입시 추가적인 방법을 제공하는 것이지 빈이름을 변경하는것은 아니다.
    - @Primary 사용
        -- 우선순위를 가지고 동작한다

    # @Primary 는 기본값처럼동작 하는거고 @Qualifier 는 매우 상세하게 동작한다
      스프링은 자동보다는 수동이 넓은범위보다는 좁은범위 선택권이 우선순위가 높다 따라서 @Qualifier 가 우선권이 높다.


##  빈의 자동등록과 수동등록의 기준
   - 편리한 자동기능을 기본으로 사용하자
   - 직접 등록하는 기술 지원 객체는 수동으로 등록
   - 다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민해보자


## 빈의 생명주기 콜백 시작
    - 스프링 빈은 간단하게 다음과 같은 라이프사이클을 가진다
        -- 객체 생성 > 의존관계 주입 ( 필드주입 세터주입에 해당 생성자주입은 예외 )
    - 스프링빈은 객체를 생성하고 의존관계 주입이 다끝난다음에 필요한 데이터를 사용할수있는 준비가 완료된다.
    - 스프링 빈의 이벤트 라이프사이클
        -- 스프링 컨테이너 생성 > 스프링 빈 생성 > 의존관계 주입 > 초기화 콜백 > 사용 > 소멸전 콜백 > 스프링 종료
    - 객체의 생성과 초기화를 분리하자.
        -- 생성자는 필수정보(파라미터)를 받고 메모리를 할당해서 객체를 생성하는 책임을 가진다.
        -- 반면에 초기화는 부분을 명확하게 나누는것이 유지보수 관점에서 좋다

    ## 스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 지원한다.
        - 인터페이스(InitializingBean, DisposableBean)
            -- 초기화, 소멸 인터페이스의 단점
                --- 이 인터페이스는 스프링전용 인터페이스다 해당코드가 스프링전용 인터페이스에 의존한다.
                --- 초기화, 소멸 메서드의 이름을 변경할수 없다.
                --- 내가 코드를 고칠수없는 외부라이브러리 에 적용할수 없다.
                --- ## 인터페이스를 초기회, 종료방법은 스프링 초창기에 나온 방법들이고 지금은 더나은 방법이 있어서 거의사용하지않는다 ##
        - 설정 정보에 초기화 메서드, 종료 메서드 지정 (initMethod = "init", destroyMethod = "close")
            -- 메서드 이름을 자유롭게 줄수있다.
            -- 스프링 빈이 스프링 코드에 의존하지않는다.
            -- 코드가 아니라 설정 정보를 사용하기 떄문에 코드를 고칠수없는 외부라이브러리에도 초기화, 종료메서드를 적용할수있다.
        - @PostConstruct, @PreDestroy 어노테이션 지원
            -- 최신 스프링에서 권장하는 방법
            -- 어노테이션 하나만 붙이면되서 매우 편리
            -- 패키지를 잘보면 javax 라고 되어있는데 스프링에 종속적인 기술이 아니라 jsr-250 이라는 자바 표준이다 따라서 스프링이 아닌 다른 컨테이너에서도 작동한다.
            -- 컴포넌트 스캔과 잘어울린다.
            -- 유일한 단점은 외부 라이브러리에 적용하지 못한다는 것이다. 외부라이브러리를 초기화하거나 종료하는 이벤트가 필요하면 2번쨰 방법을 사용하자


## 빈스코프
    - 스프링 빈은 스프링 컨테이너의 시작과 함께 생성되어 스프링 컨테이너가 종료될 때 까지 유지된다고 학습했다 이것은 스프링빈이 기본적으로 싱글톤 스코프로 생성되기때문이다

    ## 스프링은 다음과 같은 다양한 스코프를 지원한다
        - 싱글톤: 기본스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장넓은 범위 스코프이다.
        - 프로토타입 : 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우짧은 범위의 스코프이다
        - 웹관련 스코프
            -- request: 웹 요청이 들어오고 나갈때까지 유지되는 스코프이다.
                --- HTTP 요청 하나가 들어오고 나갈때 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고, 관리된다.
            -- session: 웹 세션이 생성되고 종료될때 까지 유지되는 스코프이다.
                --- HTTP Session 과 동일한 생명주기를 가지는 스코프
            -- application: 웹의 서블릿 컨텍스와 강ㅌ은 범위로 유지되는 스코프이다.
                --- 서블릿 컨텍스트 (ServletContext)와 동일한 생명주기를 가지는 스코프
            -- websocket: 웹 소켓과 동일한 생명주기를 가지는 스코프


야생형스타일 가이드

    - 스프링 입문
    - 스프링 핵심 원리 - 기본편
    - 스프링 부트와 jpa 실무 완전 정복 로드맵
        - 활용편1
        - JPA 기본편
        - 활용편 1 복습
        - 활용편2
        - 스프링 데이터 JPA
        - Querydsl



